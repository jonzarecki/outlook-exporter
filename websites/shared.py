from datetime import datetime
from typing import Dict, List

import streamlit as st

from utils.outlook_reader.calendar import OutlookCalendarEntry

SPLIT_STR = "984651651"


def export_entry_list_as_str(entries: List[OutlookCalendarEntry]):
    """Export list of outlook entries as clean string for QR consumption."""
    exported_str = st.secrets["unique_identifier"] + SPLIT_STR.join([export_entry_clean_str(ent) for ent in entries])

    return exported_str


def read_exported_str_to_entry_list(exported_str: str) -> List[OutlookCalendarEntry]:
    """Read string read from the QR code, assumes it was generated by export_entry_list_as_str()."""
    assert (
        exported_str[: len(st.secrets["unique_identifier"])] == st.secrets["unique_identifier"]
    ), "QR code was generated with this id at the beginning"

    exporter_str = exported_str[len(st.secrets["unique_identifier"]) :]
    return [import_from_clean_str(repr_s) for repr_s in exporter_str.split(SPLIT_STR)]


_KEYS = sorted(["subject", "start_date", "end_date", "location", "busystatus", "categories_colors", "conversation_id"])


def export_entry_clean_str(entry: OutlookCalendarEntry) -> str:
    """Export outlook entry as clean string for QR consumption."""
    params = dict()
    params["subject"] = entry.subject
    params["start_date"] = entry.start_date.isoformat()
    params["end_date"] = entry.end_date.isoformat()
    params["location"] = entry.location
    params["busystatus"] = entry.busystatus
    params["categories_colors"] = entry.categories_colors[0].upper() if len(entry.categories_colors) > 0 else ""
    params["conversation_id"] = entry.conversation_id

    repr_s = str([v for (k, v) in sorted(params.items(), key=lambda itm: itm[0])])

    def export_relevant_items(ent: OutlookCalendarEntry) -> Dict[str, object]:
        relevant_vals = {
            k: ent.__dict__[k].upper() if isinstance(ent.__dict__[k], str) else ent.__dict__[k] for k in _KEYS
        }
        if isinstance(relevant_vals["categories_colors"], list) and len(relevant_vals["categories_colors"]) > 0:
            relevant_vals["categories_colors"] = relevant_vals["categories_colors"][0].upper()
        else:
            relevant_vals["categories_colors"] = ""
        return relevant_vals

    repr_s = _encode_to_alphanumeric(repr_s)
    assert export_relevant_items(import_from_clean_str(repr_s)) == export_relevant_items(entry), (
        "import and export should be equal \n"
        f"{export_relevant_items(import_from_clean_str(repr_s))}\n"
        f"{export_relevant_items(entry)}"
    )
    return repr_s


_ENCODE_DICT = {  # $ % *+-./:
    ":": "9-8".upper(),
    " ": "0-1".upper(),
    "'": "a-b".upper(),
    "#": "c-d".upper(),
    "[": "e-f".upper(),
    "]": "g-h".upper(),
    ",": "i-j".upper(),
    "+": "k-l".upper(),
}
_DECODE_DICT = {v: k for k, v in _ENCODE_DICT.items()}


def _encode_to_alphanumeric(s: str) -> str:
    for enc_k, enc_v in _ENCODE_DICT.items():
        assert enc_v not in s, f"encoded value {enc_v} appears in string {s}"
        s = s.replace(enc_k, enc_v)
    s = s.upper()
    return s


def _decode_from_encoded_alphnanumeric(s: str) -> str:
    for enc_k, enc_v in _DECODE_DICT.items():
        s = s.replace(enc_k, enc_v)
    return s


def import_from_clean_str(repr_s: str) -> OutlookCalendarEntry:
    """Read string read from the QR code, assumes it was generated by export_entry_clean_str()."""
    values = eval(_decode_from_encoded_alphnanumeric(repr_s))  # pylint: disable=W0123
    params = dict(zip(_KEYS, values))
    assert isinstance(params, dict), "exported string should contain a string of a dict items"

    params["start_date"] = datetime.fromisoformat(params["start_date"])
    params["end_date"] = datetime.fromisoformat(params["end_date"])
    params["categories_colors"] = [params["categories_colors"]]
    return OutlookCalendarEntry(**params)
